---
title: 【c++】如何使用默认成员函数
date: 2023-04-29 11:11:02
cover: https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B01.png
tags:
- 成员函数
- 类与对象
categories:
- c/c++
---

>在C\+\+中，有许多`默认成员函数`，如默认构造函数、拷贝构造函数和析构函数等。这些默认成员函数在代码中扮演着重要的角色，它们可以帮助开发者快速`构建对象、复制对象和释放对象`。然而，这些默认成员函数的使用也有一些需要注意的细节和技巧。本文将详细介绍C\+\+中的默认成员函数，包括其作用、使用方法、注意事项和实例说明等，旨在帮助读者深入了解和掌握这些重要的语言特性，从而写出更加高效可靠的代码。

# 🕎概览
一个类没有成员，称为`空类`。但一个空类却并不为空。
编译器会在其中为开发者默认生成了两大类成员函数。
<img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B01.png'>


构造函数：当`创建`一个对象时，如果没有`显式地`提供构造函数，编译器会自动生成一个默认构造函数。默认构造函数的主要功能是`初始化成员变量`，使对象能够正确地工作。

析构函数：当一个对象`生命周期结束`时，如果没有`显式地`提供析构函数，编译器会自动生成一个默认的析构函数。析构函数的主要功能是`释放对象占用的资源`，如释放动态分配的内存等。

拷贝构造函数：当一个对象要被`复制`到另一个对象中时，如果没有`显式地`提供拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。拷贝构造函数的主要功能是将一个已有对象的值复制到新的对象中。

拷贝赋值运算符：当一个对象要被`赋值`给另一个对象时，如果没有`显式地`提供拷贝赋值运算符，编译器会自动生成一个默认的拷贝赋值运算符。拷贝赋值运算符的主要功能是将一个已有对象的值赋值给另一个对象。


> 如果我们在类中显式地定义了这些成员函数，则编译器不会再生成默认版本。而且，如果我们定义了其中的某一个成员函数，则最好`也定义其它成员函数`，以保证它们能够协同工作，避免出现一些难以预料的问题。

`取地址重载`也可以算作默认成员函数的成员。主要是普通对象和const对象取地址，在文章后面也会提到。

创建一个class data，作为示例。
```c++
class data{
    private:
	int _day;
	int _month;
	int _year;
};
```

# ☮️构造函数

再未了解构造函数前，我们想要对类中private修饰的成员变量赋值，需要写一个函数来访问它。
```c++
	date d1;
	d1._day = 2;
```
这样的案例是错误的，编译器报错：`成员不可访问`。因为此时的_day成员被private所修饰，只能在类里对其进行访问。
使用private的好处是极多的。建议将类中的`成员变量`用`private`来修饰实现封装，是因为这样能够有效地`保护数据，防止外部的非法访问和修改`，从而提高程序的安全性和可靠性。
封装可以做到：

1. 隐藏实现细节：将成员变量封装在类的私有部分，可以隐藏实现细节，避免外部直接访问和修改，从而保证数据的`安全性和完整性`。

2. 提高代码复用性：类的成员变量只有在`类的内部`才能访问，所以可以在类的内部定义一些公共的成员函数，通过这些函数来访问和修改成员变量，从而实现代码的复用。

3. 方便代码维护：成员变量只能通过类的公共接口来访问，所以如果需要修改成员变量或者添加新的成员变量，只需要`修改类的公共接口`，而不需要修改外部的代码。


那么此时我们可能会采取写一个init函数来对成员变量进行初始化。这也正是`构造函数`的职能。
```c++
void init(int day, int month, int year) {
		_day = day;
		_month = month;
		_year = year;
	}
```
构造函数并不是如他的名字——去创建一个对象，而是参与了`对象中成员变量的初始化`。
> 构造函数是一个特殊的函数，`名字与类名是相同`的，在创建对象时就由编译器`直接调用`，且在对象整个生命周期内`只调用一次`。

构造函数有这样的几个特点：
1. 函数名与类名是`相同`的。比如date类的构造函数就叫date。
2. 构造函数是`没有返回值`的。
3. 当对象进行实例化时，编译器会`自动`调用此函数。
4. 构造函数是可以进行重载的。

```c++
date() {

	}
date(int day, int month, int year) {
		_day = day;
		_month = month;
		_year = year;
	}
```
如上，这样就实现了两个构造函数——一个`有参构造`，一个`无参构造`。因为其支持重载，所以这样设置是没问题的。
```c++
	date d1(12,1,2012);  //调用有参构造
	date d2;  //调用无参构造
```

> 当用户未进行显示定义时，编译器会`自动`生成一个`无参`构造函数。但一旦用户定义了，编译器就不会生成了。

看到这里可能有人会有疑惑，默认的构造函数又不能传参进去，初始化的好像也都是`随机值`。
但在c\+\+中，类型可以被分为两种：
<img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B02.png'>

像int，double这样的类型就是内置类型，也被称作基本类型。
而像上面定义的date类，就被叫做自定义类型。

编译器在调用无参构造时，内置类型可能是随机值，也可能是0这样的值，这点`取决于编译器`。而自定义类型就一定会调用该类自己的`默认成员函数`。
我们又创建了一个类——student，并将其放在date类中。
```c++
class student {
public:
	student() {
		age = 10;
		name = "chengzi";
	}
private:
	string name;
	int age;
};

class date {
public:
	void init(int day, int month, int year) {
		_day = day;
		_month = month;
		_year = year;
	}
	//date() {

	//}
	//date(int day, int month, int year) {
	//	_day = day;
	//	_month = month;
	//	_year = year;
	//}
private:
	int _day;
	int _month;
	int _year;
	student stu;
};

```

以下是运行截图（vs2022）：
<img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B03.png'>
可以看到，虽然date的几个基本类型是随机值，但stu里带的成员变量因为`调用了自身的默认构造`，所以不是随机值。注意，调用的`必须`是默认构造也就是无参的哦。

在c\+\+11中规定： 内置类型可以再类中声明时给出默认值。
```c++
    int _day=1;
	int _month=1;
	int _year=1;
	student stu;
```
运行截图：
<img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B04.png'>

`无参构造`和`全缺省`都被称为默认构造，但两者只能存在一个，否则编译器不知道调用哪一个。

# ☪️析构函数
析构函数负责对象的`销毁`。
但析构函数不是对对象本身进行销毁，而是在编译器`出手销毁`时，作为一个强有力的工具，来帮助完成`对象资源`的清理。
析构函数的特征:
1. 析构函数的名就是在`类名`前加上一个`~`即可。
2. 同样的，析构函数没有返回值。
3. 析构函数是`不支持重载`的。
4. 在对象生命周期结束时，由编译器亲自调用析构函数。

析构函数适用于哪些情景呢？
1. 动态分配内存：当我们使用动态分配内存时，需要使用析构函数来释放这些动态分配的内存，防止`内存泄漏`。
2. 对象销毁前的清理工作：当我们需要在对象销毁前进行一些清理工作时，可以使用析构函数来实现。例如，我们可以在析构函数中关闭对象的一些状态，保存对象的一些状态等等。

所以当类中没有申请资源时，就不用写析构函数了，例如上面date类或者student类。而一旦类中进行了动态内存分配，我们就必须得自己写一个析构函数。
例如我们创建了一个类——stack。就必须要手动进行释放。
```c++
class stack {
public:
	stack(int capacity) {
		arr = (int*)malloc(sizeof(int) * capacity);
		currentsize = 0;
	}
	~stack() {
		if (arr) {
			free(arr);
			arr = NULL;
		}
	}
private:
	int* arr;
	int capacity;
	int currentsize;
};
```
同样的，默认的析构函数会调用自定义成员变量默认的析构函数（如果类中存在自定义成员变量的话）。


# ✡️拷贝构造函数



